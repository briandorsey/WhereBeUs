API Thinking

class User(db.Model):
   display_name = db.StringProperty() # DEAL WITH COLLISIONS BY CHOOSING TWITTER
   profile_image_url = db.LinkProperty() # DEAL WITH COLLISIONS BY CHOOSING TWITTER
   # this has "services" and "locations" right on it. they are read-only.

   message = db.StringProperty()
   message_time = db.DateTimeProperty()    

class LocationUpdate(db.Model):
   user = db.ReferenceProperty(User, collection_name = "locations")
   location = db.GeoPtProperty()    
   update_time = db.DateTimeProperty()
   horizontal_accuracy = db.FloatProperty()

class UserService(db.Model):
   user = db.ReferenceProperty(User, collection_name = "services")
   service_type = db.StringProperty()  # "twitter"
   id_on_service = db.IntegerProperty() # 12345
   friend_ids = db.ListProperty(int)   # [12345, 6789]




MAKE_THE_CALL (url == ?)
POST

a list of services to get updates for
and a flag indicating whether I want a list of updates back

{
   "services":
   [
       {
           "service_type": "twitter",
           "id_on_service": 12345,
           "friends": [67890, 999, 312],       /* optional. [] means I HAVE NO FRIENDS. not present means MY FRIENDS HAVEN'T CHANGED */
       },


       {
           "service_type": "twitter",
           "id_on_service": 12345,
           "display_name": "Big display name",
           "profile_image_url": "http://foo/bar.png",
       },
   ],

   "want_updates": true,
   "latitude": 77.33,
   "longitude": 99.22,

   "message": "My current message.", /* optional. not present means my message hasn't changed. null means clear out my message. */
}

RETURN VALUE:

a list of location updates, service independent.
we must de-dup each of these updates by User model.

{
   "success": true,

   "updates":
   [
       {
           "display_name": "Brian Dorsey",
           "profile_image_url": "http://foo/",
           "latitude": 27.333,
           "longitude": 99.444,
           "update_time": "000000+0000Z",

           "message": "You people rock", # optional
           "message_time": "000000+00000Z", # optional
       },

       ...
   ],
}




---
NOTE
NOTE
NOTE I removed this from main.py because I don't think we want to support GET in our update handler (?)
NOTE
NOTE
NOTE

This API call should probably not support GET...
def get(self, hashtag):
    try:
        update_list = []
        updates = LocationUpdate.all().filter('hashtag =', hashtag).fetch(100)
        for update in updates:
            update_list.append(HashTagHandler.location_update_dictionary(update))
    except:
        response = {'success': False, 'message': 'Datastore failure', 'call_again_seconds': 15, 'updates': []}
    else:
        response = {'success': True, 'message': 'OK', 'call_again_seconds': 15, 'updates': update_list}

    self.response.headers['Content-Type'] = 'application/json'
    callback = self.request.get("callback")
    if callback:
        data = '%s(%s);' % (callback, simplejson.dumps(response))
        self.response.out.write(data)
    else:
        self.response.out.write(simplejson.dumps(response))
        #sys.__stdout__.write(simplejson.dumps(response))
        #sys.__stdout__.flush()
